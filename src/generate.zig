pub fn write_reg_types(db: Database, writer: anytype) !void {
    try writer.writeAll(
        \\// Generated by https://github.com/bcrist/microbe-regz
        \\const microbe = @import("microbe");
        \\const chip = @import("chip");
        \\const MMIO = microbe.MMIO;
        \\
        \\pub const Exception = enum(u9) {
        \\    none = 0,
        \\    Reset = 1,
        \\
    );

    for (db.interrupts.items) |interrupt| {
        try write_comment(interrupt.description, writer);

        try writer.print("{s} = {},\n", .{
            std.zig.fmtId(interrupt.name),
            interrupt.index + 16,
        });

        if (interrupt.description.len > 0) try writer.writeByte('\n');
    }

    try writer.writeAll(
        \\
        \\    pub fn to_interrupt(self: Exception) ?Interrupt {
        \\        const num = @intFromEnum(self);
        \\        if (num < 16 or num >= 48) return null;
        \\        const irq: u5 = @intCast(num - 16);
        \\        return @enumFromInt(irq);
        \\    }
        \\};
        \\
        \\pub const Interrupt = enum(u5) {
        \\
    );

    for (db.interrupts.items) |interrupt| {
        if (interrupt.index >= 0) {
            try writer.print("{s} = {},\n", .{
                std.zig.fmtId(interrupt.name),
                interrupt.index,
            });
        }
    }

    try writer.writeAll(
        \\
        \\    pub fn to_exception(self: Interrupt) Exception {
        \\        const num: u9 = @intFromEnum(self);
        \\        return @enumFromInt(num + 16);
        \\    }
        \\};
        \\
        \\pub const Vector_Table = extern struct {
        \\    const Handler = chip.interrupts.Handler;
        \\    const unhandled = chip.interrupts.unhandled;
        \\
        \\    initial_stack_pointer: *const fn () callconv(.C) void,
        \\    Reset: Handler,
        \\
    );

    var index: i32 = -14;
    for (db.interrupts.items) |interrupt| {
        while (index < interrupt.index) : (index += 1) {
            try writer.print("_reserved_{x}: u32 = 0,\n", .{ (index + 16) * 4 });
        }

        if (index > interrupt.index) {
            log.warn("skipping interrupt: {s}", .{ interrupt.name });
            continue;
        }

        try writer.print("{s}: Handler = unhandled(.{s}),\n", .{
            std.zig.fmtId(interrupt.name),
            std.zig.fmtId(interrupt.name),
        });

        index += 1;
    }

    try writer.writeAll("};\n");

    for (db.groups.items) |group| {
        try writer.writeByte('\n');
        try write_comment(group.description, writer);
        if (group.name.len == 0) {
            try write_peripheral_group_types(group, writer, "reg_types/");
        } else if (group.separate_file) {
            try writer.print("pub const {s} = @import(\"reg_types/{s}.zig\");\n", .{
                std.zig.fmtId(group.name),
                std.fmt.fmtSliceEscapeUpper(group.name),
            });
        } else {
            try writer.print("pub const {s} = struct {{\n", .{
                std.zig.fmtId(group.name),
            });
            try write_peripheral_group_types(group, writer, "reg_types/");
            try writer.writeAll("};\n");
        }
    }
}

pub fn write_peripheral_group_types(group: Peripheral_Group, writer: anytype, import_prefix: []const u8) !void {
    for (group.data_types.items) |data_type| {
        if (data_type.should_inline()) continue;

        try writer.writeByte('\n');
        try write_comment(data_type.description, writer);
        try writer.print("pub const {s} = ", .{
            std.zig.fmtId(data_type.zig_name()),
        });

        try write_data_type_impl(group, data_type, "", import_prefix, writer);
        try writer.writeAll(";\n");
    }
}

fn write_data_type_ref(group: Peripheral_Group, data_type: Data_Type, reg_types_prefix: []const u8, import_prefix: []const u8, writer: anytype) @TypeOf(writer).Error!void {
    if (data_type.should_inline()) {
        try write_data_type_impl(group, data_type, reg_types_prefix, import_prefix, writer);
    } else {
        try writer.print("{s}{s}", .{ reg_types_prefix, std.zig.fmtId(data_type.zig_name()) });
    }
}

fn write_data_type_impl(group: Peripheral_Group, data_type: Data_Type, reg_types_prefix: []const u8, import_prefix: []const u8, writer: anytype) @TypeOf(writer).Error!void {
    switch (data_type.kind) {
        .unsigned => try writer.print("u{}", .{ data_type.size_bits }),
        .signed => try writer.print("i{}", .{ data_type.size_bits }),
        .boolean => try writer.writeAll("bool"),
        .anyopaque => try writer.writeAll("anyopaque"),
        .external => |info| {
            if (std.mem.endsWith(u8, info.import, ".zig")) {
                try writer.print("@import(\"{s}{s}\")", .{
                    std.fmt.fmtSliceEscapeUpper(import_prefix),
                    std.fmt.fmtSliceEscapeUpper(info.import),
                });
            } else if (std.mem.startsWith(u8, info.import, "microbe.")) {
                try writer.writeAll("microbe");
                var iter = std.mem.tokenizeScalar(u8, info.import["microbe.".len..], '.');
                while (iter.next()) |tok| {
                    try writer.print(".{s}", .{ std.zig.fmtId(tok) });
                }
            } else if (std.mem.startsWith(u8, info.import, "chip.")) {
                try writer.writeAll("chip");
                var iter = std.mem.tokenizeScalar(u8, info.import["chip.".len..], '.');
                while (iter.next()) |tok| {
                    try writer.print(".{s}", .{ std.zig.fmtId(tok) });
                }
            } else if (std.mem.indexOfScalar(u8, info.import, '.')) |dot| {
                try writer.print("@import(\"{s}\")", .{
                    std.fmt.fmtSliceEscapeUpper(info.import[0..dot]),
                });
                var iter = std.mem.tokenizeScalar(u8, info.import[dot + 1 ..], '.');
                while (iter.next()) |tok| {
                    try writer.print(".{s}", .{ std.zig.fmtId(tok) });
                }
            } else if (std.mem.eql(u8, info.import, "microbe")) {
                try writer.writeAll("microbe");
            } else if (std.mem.eql(u8, info.import, "chip")) {
                try writer.writeAll("chip");
            } else {
                try writer.print("@import(\"{s}\")", .{
                    std.fmt.fmtSliceEscapeUpper(info.import),
                });
            }
            var iter = std.mem.tokenizeScalar(u8, data_type.zig_name(), '.');
            while (iter.next()) |tok| {
                try writer.print(".{s}", .{ std.zig.fmtId(tok) });
            }
        },
        .pointer => |info| {
            try writer.writeByte('*');
            if (info.allow_zero) {
                try writer.writeAll("allowzero ");
            }
            if (info.constant) {
                try writer.writeAll("const ");
            }
            try write_data_type_ref(group, group.data_types.items[info.data_type], reg_types_prefix, import_prefix, writer);
        },
        .register => |info| {
             try writer.writeAll("MMIO(");
             try write_data_type_ref(group, group.data_types.items[info.data_type], reg_types_prefix, import_prefix, writer);
             try writer.print(", .{s})", .{ @tagName(info.access) });
        },
        .collection => |info| {
            try writer.print("[{}]", .{ info.count });
            try write_data_type_ref(group, group.data_types.items[info.data_type], reg_types_prefix, import_prefix, writer);
        },
        .alternative => |fields| {
            try writer.writeAll("extern union {\n");
            for (fields) |field| {
                try write_comment(field.description, writer);
                try writer.print("{s}: ", .{ std.zig.fmtId(field.name) });
                try write_data_type_ref(group, group.data_types.items[field.data_type], reg_types_prefix, import_prefix, writer);
                try writer.writeAll(",\n");
                if (field.description.len > 0) try writer.writeByte('\n');
            }
            try writer.writeAll("}");
        },
        .structure => |fields| {
            try writer.writeAll("extern struct {\n");
            var offset_bytes: u32 = 0;
            for (fields) |field| {
                if (offset_bytes < field.offset_bytes) {
                    try writer.print("_reserved_{x}: [{}]u8 = undefined,\n", .{
                        offset_bytes,
                        field.offset_bytes - offset_bytes,
                    });
                    offset_bytes = field.offset_bytes;
                }
                try write_comment(field.description, writer);
                try writer.print("{s}: ", .{ std.zig.fmtId(field.name) });
                const field_data_type = group.data_types.items[field.data_type];
                try write_data_type_ref(group, field_data_type, reg_types_prefix, import_prefix, writer);
                try write_data_type_assign(group, field_data_type, reg_types_prefix, import_prefix, field.default_value, writer);
                try writer.writeAll(",\n");
                if (field.description.len > 0) try writer.writeByte('\n');
                offset_bytes += (field_data_type.size_bits + 7) / 8;
            }
            if (offset_bytes < (data_type.size_bits + 7) / 8) {
                try writer.print("_reserved_{x}: [{}]u8 = undefined,\n", .{
                    offset_bytes,
                    (data_type.size_bits + 7) / 8 - offset_bytes,
                });
            }
            try writer.writeAll("}");
        },
        .bitpack => |fields| {
            try writer.print("packed struct (u{}) {{\n", .{ data_type.size_bits });
            var offset_bits: u32 = 0;
            for (fields) |field| {
                if (offset_bits < field.offset_bits) {
                    try writer.print("_reserved_{x}: u{} = 0,\n", .{
                        offset_bits,
                        field.offset_bits - offset_bits,
                    });
                    offset_bits = field.offset_bits;
                }
                try write_comment(field.description, writer);
                try writer.print("{s}: ", .{ std.zig.fmtId(field.name) });
                const field_data_type = group.data_types.items[field.data_type];
                try write_data_type_ref(group, field_data_type, reg_types_prefix, import_prefix, writer);
                try write_data_type_assign(group, field_data_type, reg_types_prefix, import_prefix, field.default_value, writer);
                try writer.writeAll(",\n");
                if (field.description.len > 0) try writer.writeByte('\n');
                offset_bits += field_data_type.size_bits;
            }
            if (offset_bits < data_type.size_bits) {
                try writer.print("_reserved_{x}: u{} = 0,\n", .{
                    offset_bits,
                    data_type.size_bits - offset_bits,
                });
            }
            try writer.writeAll("}");
        },
        .enumeration => |fields| {
            try writer.print("enum (u{}) {{\n", .{ data_type.size_bits });
            var num_fields: usize = 0;
            for (fields) |field| {
                num_fields += 1;
                try write_comment(field.description, writer);
                try writer.print("{s} = ", .{
                    std.zig.fmtId(field.name),
                });
                if (data_type.size_bits > 4) {
                    try writer.print("0x{X},\n", .{ field.value });
                } else {
                    try writer.print("{},\n", .{ field.value });
                }
                if (field.description.len > 0) try writer.writeByte('\n');
            }
            if (num_fields < (@as(u64, 1) << @intCast(data_type.size_bits))) {
                try writer.writeAll("_,\n");
            }
            try writer.writeAll("}");
        },
    }
}

fn write_data_type_assign(group: Peripheral_Group, data_type: Data_Type, reg_types_prefix: []const u8, import_prefix: []const u8, value: u64, writer: anytype) !void {
    switch (data_type.kind) {
        .unsigned => {
            if (value > 9) {
                try writer.print(" = 0x{X}", .{ value });
            } else {
                try writer.print(" = {}", .{ value });
            }
        },
        .signed => {
            try writer.print(" = {}", .{ value });
        },
        .boolean => {
            try writer.writeAll(if (value == 0) " = false" else " = true");
        },
        .enumeration => |fields| {
            for (fields) |field| {
                if (field.value == value) {
                    try writer.print(" = .{s}", .{ std.zig.fmtId(field.name) });
                    break;
                }
            } else try writer.print(" = @enumFromInt({})", .{ value });
        },
        .pointer => {
            try writer.writeAll(" = @ptrFromInt(");
            if (value > 9) {
                try writer.print("0x{X}", .{ value });
            } else {
                try writer.print("{}", .{ value });
            }
            try writer.writeByte(')');
        },
        .bitpack => {
            try writer.print(" = @bitCast(@as(u{}, ", .{ data_type.size_bits });
            if (value > 9) {
                try writer.print("0x{X}", .{ value });
            } else {
                try writer.print("{}", .{ value });
            }
            try writer.writeAll("))");
        },
        .external => |info| {
            if (info.from_int) |from_int| {
                try writer.writeAll(" = ");
                if (std.mem.startsWith(u8, from_int, ".")) {
                    try write_data_type_ref(group, data_type, reg_types_prefix, import_prefix, writer);
                }
                try writer.writeAll(from_int);
            } else {
                try writer.writeAll(" = microbe.util.from_int(");
                try write_data_type_ref(group, data_type, reg_types_prefix, import_prefix, writer);
                try writer.writeAll(", ");
            }
            if (value > 9) {
                try writer.print("0x{X}", .{ value });
            } else {
                try writer.print("{}", .{ value });
            }
            try writer.writeByte(')');
        },
        .register, .collection, .alternative, .structure, .anyopaque => {},
    }
}

pub fn write_peripheral_instances(db: Database, writer: anytype) !void {
    try writer.writeAll(
        \\// Generated by https://github.com/bcrist/microbe-regz
        \\const types = @import("reg_types.zig");
        \\
        \\
    );

    for (db.groups.items) |group| {
        var types_prefix: []const u8 = undefined;
        if (group.name.len > 0) {
            types_prefix = try std.fmt.allocPrint(db.gpa, "types.{s}.", .{ std.zig.fmtId(group.name) });
        } else {
            types_prefix = try db.gpa.dupe(u8, "types.");
        }
        defer db.gpa.free(types_prefix);

        for (group.peripherals.items) |peripheral| {
            if (peripheral.deleted) continue;

            try write_comment(peripheral.description, writer);
            try writer.print("pub const {s}: *volatile ", .{ std.zig.fmtId(peripheral.name) });
            try write_data_type_ref(group, group.data_types.items[peripheral.data_type], types_prefix, "reg_types/", writer);
            try writer.print(" = @ptrFromInt(0x{X});\n", .{ peripheral.base_address });
        }
    }
}

pub fn write_comment(comment: []const u8, writer: anytype) !void {
    if (comment.len == 0) return;

    try writer.writeByte('\n');
    var lf_it = std.mem.tokenizeSequence(u8, comment, "\\n");
    while (lf_it.next()) |line| {
        try writer.writeAll("/// ");

        var first_token = true;
        var tok_it = std.mem.tokenizeAny(u8, line, "\n\r \t");
        while (tok_it.next()) |token| {
            if (first_token) first_token = false else try writer.writeByte(' ');
            try writer.writeAll(token);
        }

        try writer.writeByte('\n');
    }
}

const Database = @import("Database.zig");
const Peripheral_Group = @import("Peripheral_Group.zig");
const Data_Type = @import("Data_Type.zig");
const log = std.log.scoped(.microbe_regz);
const std = @import("std");
